; Listing generated by Microsoft (R) Optimizing Compiler Version 19.16.27034.0 

include listing.inc

INCLUDELIB OLDNAMES

PUBLIC	??_C@_0CC@DEJEICHL@?2SystemRoot?2system32?2ntoskrnl?4e@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0P@EFCCFGKI@xx?$DP?$DP?$DP?$DP?$DPxxxxx?$DPx@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0P@JIBKLKFL@L?$IL?$AA?$AA?$AA?$AA?$AAL?$IL?IM?$IF?$AAt@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0BC@GGMFPPBL@xxx?$DP?$DP?$DP?$DPxxx?$DP?$DP?$DP?$DPxxx@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0BC@LCGEEDHA@H?$IN?$AN?$AA?$AA?$AA?$AAL?$IJ5?$AA?$AA?$AA?$AAI?$IL?i@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0CA@MAGIKHML@Failed?5to?5find?5PiddbCachetable?$CB@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1BE@MNFNHFL@?$AA3?$AA2?$AA4?$AA6?$AA1?$AA?4?$AAs?$AAy?$AAs@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
EXTRN	__imp_ZwClose:PROC
EXTRN	__imp_DbgPrint:PROC
EXTRN	__imp_PsCreateSystemThread:PROC
EXTRN	__imp_ZwQuerySystemInformation:PROC
EXTRN	__imp_MmIsAddressValid:PROC
;	COMDAT ??_C@_1BE@MNFNHFL@?$AA3?$AA2?$AA4?$AA6?$AA1?$AA?4?$AAs?$AAy?$AAs@FNODOBFM@
text$s	SEGMENT
??_C@_1BE@MNFNHFL@?$AA3?$AA2?$AA4?$AA6?$AA1?$AA?4?$AAs?$AAy?$AAs@FNODOBFM@ DB '3'
	DB	00H, '2', 00H, '4', 00H, '6', 00H, '1', 00H, '.', 00H, 's', 00H
	DB	'y', 00H, 's', 00H, 00H, 00H			;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0CA@MAGIKHML@Failed?5to?5find?5PiddbCachetable?$CB@FNODOBFM@
text$s	SEGMENT
??_C@_0CA@MAGIKHML@Failed?5to?5find?5PiddbCachetable?$CB@FNODOBFM@ DB 'Fa'
	DB	'iled to find PiddbCachetable!', 00H		;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0BC@LCGEEDHA@H?$IN?$AN?$AA?$AA?$AA?$AAL?$IJ5?$AA?$AA?$AA?$AAI?$IL?i@FNODOBFM@
text$s	SEGMENT
??_C@_0BC@LCGEEDHA@H?$IN?$AN?$AA?$AA?$AA?$AAL?$IJ5?$AA?$AA?$AA?$AAI?$IL?i@FNODOBFM@ DB 'H'
	DB	08dH, 0dH, 00H, 00H, 00H, 00H, 'L', 089H, '5', 00H, 00H, 00H, 00H
	DB	'I', 08bH, 0e9H, 00H				;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0BC@GGMFPPBL@xxx?$DP?$DP?$DP?$DPxxx?$DP?$DP?$DP?$DPxxx@FNODOBFM@
text$s	SEGMENT
??_C@_0BC@GGMFPPBL@xxx?$DP?$DP?$DP?$DPxxx?$DP?$DP?$DP?$DPxxx@FNODOBFM@ DB 'x'
	DB	'xx????xxx????xxx', 00H			;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0P@JIBKLKFL@L?$IL?$AA?$AA?$AA?$AA?$AAL?$IL?IM?$IF?$AAt@FNODOBFM@
text$s	SEGMENT
??_C@_0P@JIBKLKFL@L?$IL?$AA?$AA?$AA?$AA?$AAL?$IL?IM?$IF?$AAt@FNODOBFM@ DB 'L'
	DB	08bH, 00H, 00H, 00H, 00H, 00H, 'L', 08bH, 0c9H, 'M', 085H, 00H
	DB	't', 00H					;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0P@EFCCFGKI@xx?$DP?$DP?$DP?$DP?$DPxxxxx?$DPx@FNODOBFM@
text$s	SEGMENT
??_C@_0P@EFCCFGKI@xx?$DP?$DP?$DP?$DP?$DPxxxxx?$DPx@FNODOBFM@ DB 'xx?????x'
	DB	'xxxx?x', 00H				;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0CC@DEJEICHL@?2SystemRoot?2system32?2ntoskrnl?4e@FNODOBFM@
text$s	SEGMENT
??_C@_0CC@DEJEICHL@?2SystemRoot?2system32?2ntoskrnl?4e@FNODOBFM@ DB '\Sys'
	DB	'temRoot\system32\ntoskrnl.exe', 00H		;  ?? ::FNODOBFM::`string'
PUBLIC	??$find_pattern@_K@@YA_KPEAX_KPEBD2@Z		; find_pattern<unsigned __int64>
PUBLIC	DriverEntry
PUBLIC	?clean_piddb_cache@@YAXXZ			; clean_piddb_cache
PUBLIC	?CleanUnloadedDrivers@@YAEXZ			; CleanUnloadedDrivers
PUBLIC	?FindPattern@@YA_K_K0PEAEPEAD@Z			; FindPattern
PUBLIC	?bDataCompare@@YAEPEBE0PEBD@Z			; bDataCompare
PUBLIC	?dereference@@YA_K_KI@Z				; dereference
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$find_pattern@_K@@YA_KPEAX_KPEBD2@Z DD imagerel $LN28
	DD	imagerel $LN28+211
	DD	imagerel $unwind$??$find_pattern@_K@@YA_KPEAX_KPEBD2@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$DriverEntry DD imagerel $LN5
	DD	imagerel $LN5+97
	DD	imagerel $unwind$DriverEntry
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?clean_piddb_cache@@YAXXZ DD imagerel $LN60
	DD	imagerel $LN60+536
	DD	imagerel $unwind$?clean_piddb_cache@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?CleanUnloadedDrivers@@YAEXZ DD imagerel $LN50
	DD	imagerel $LN50+118
	DD	imagerel $unwind$?CleanUnloadedDrivers@@YAEXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?CleanUnloadedDrivers@@YAEXZ DD imagerel $LN50+118
	DD	imagerel $LN50+190
	DD	imagerel $chain$0$?CleanUnloadedDrivers@@YAEXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?CleanUnloadedDrivers@@YAEXZ DD imagerel $LN50+190
	DD	imagerel $LN50+419
	DD	imagerel $chain$1$?CleanUnloadedDrivers@@YAEXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?FindPattern@@YA_K_K0PEAEPEAD@Z DD imagerel $LN30
	DD	imagerel $LN30+128
	DD	imagerel $unwind$?FindPattern@@YA_K_K0PEAEPEAD@Z
;	COMDAT xdata
xdata	SEGMENT
$unwind$?FindPattern@@YA_K_K0PEAEPEAD@Z DD 060a02H
	DD	06161601H
	DD	02740aH
	DD	013405H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?CleanUnloadedDrivers@@YAEXZ DD 020022H
	DD	06291609H
	DD	imagerel $LN50
	DD	imagerel $LN50+118
	DD	imagerel $unwind$?CleanUnloadedDrivers@@YAEXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?CleanUnloadedDrivers@@YAEXZ DD 020522H
	DD	0b5405H
	DD	imagerel $LN50
	DD	imagerel $LN50+118
	DD	imagerel $unwind$?CleanUnloadedDrivers@@YAEXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?CleanUnloadedDrivers@@YAEXZ DD 081102H
	DD	0c3411H
	DD	0f00d3211H
	DD	0c009e00bH
	DD	060067007H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?clean_piddb_cache@@YAXXZ DD 0c1402H
	DD	0600160cH
	DD	0103414H
	DD	0f0105214H
	DD	0d00ce00eH
	DD	07008c00aH
	DD	050066007H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$DriverEntry DD 030402H
	DD	06131601H
	DD	08204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$find_pattern@_K@@YA_KPEAX_KPEBD2@Z DD 0e2102H
	DD	062a060aH
	DD	0d6421H
	DD	0c5421H
	DD	0b3421H
	DD	0f01d3221H
	DD	0d019e01bH
	DD	07015c017H
; Function compile flags: /Ogtp
; File c:\users\aapo\desktop\fortnite_shait\kernel rpm\dummy\main.cpp
;	COMDAT ?dereference@@YA_K_KI@Z
_TEXT	SEGMENT
address$ = 8
offset$dead$ = 16
?dereference@@YA_K_KI@Z PROC				; dereference, COMDAT

; 243  : 	if (address == 0)

  00000	48 85 c9	 test	 rcx, rcx
  00003	75 03		 jne	 SHORT $LN2@dereferenc

; 244  : 		return 0;

  00005	33 c0		 xor	 eax, eax

; 247  : }

  00007	c3		 ret	 0
$LN2@dereferenc:

; 245  : 
; 246  : 	return address + (int)((*(int*)(address + offset) + offset) + sizeof(int));

  00008	8b 41 03	 mov	 eax, DWORD PTR [rcx+3]
  0000b	83 c0 07	 add	 eax, 7
  0000e	48 98		 cdqe
  00010	48 03 c1	 add	 rax, rcx

; 247  : }

  00013	c3		 ret	 0
?dereference@@YA_K_KI@Z ENDP				; dereference
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\aapo\desktop\fortnite_shait\kernel rpm\dummy\main.cpp
;	COMDAT ?bDataCompare@@YAEPEBE0PEBD@Z
_TEXT	SEGMENT
pData$ = 8
bMask$dead$ = 16
szMask$dead$ = 24
?bDataCompare@@YAEPEBE0PEBD@Z PROC			; bDataCompare, COMDAT

; 250  : {

  00000	b0 78		 mov	 al, 120			; 00000078H
  00002	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:__ImageBase
  00009	33 d2		 xor	 edx, edx
  0000b	0f 1f 44 00 00	 npad	 5
$LL4@bDataCompa:

; 252  : 		if (*szMask == 'x' && *pData != *bMask)

  00010	3c 78		 cmp	 al, 120			; 00000078H
  00012	75 0d		 jne	 SHORT $LN2@bDataCompa
  00014	42 0f b6 84 02
	00 00 00 00	 movzx	 eax, BYTE PTR ??_C@_0P@JIBKLKFL@L?$IL?$AA?$AA?$AA?$AA?$AAL?$IL?IM?$IF?$AAt@FNODOBFM@[rdx+r8]
  0001d	38 01		 cmp	 BYTE PTR [rcx], al
  0001f	75 17		 jne	 SHORT $LN8@bDataCompa
$LN2@bDataCompa:

; 251  : 	for (; *szMask; ++szMask, ++pData, ++bMask)

  00021	42 0f b6 84 02
	01 00 00 00	 movzx	 eax, BYTE PTR ??_C@_0P@EFCCFGKI@xx?$DP?$DP?$DP?$DP?$DPxxxxx?$DPx@FNODOBFM@[rdx+r8+1]
  0002a	48 ff c2	 inc	 rdx
  0002d	48 ff c1	 inc	 rcx
  00030	84 c0		 test	 al, al
  00032	75 dc		 jne	 SHORT $LL4@bDataCompa

; 254  : 
; 255  : 	return (*szMask) == 0;

  00034	0f 94 c0	 sete	 al

; 256  : }

  00037	c3		 ret	 0
$LN8@bDataCompa:

; 253  : 			return 0;

  00038	32 c0		 xor	 al, al

; 256  : }

  0003a	c3		 ret	 0
?bDataCompare@@YAEPEBE0PEBD@Z ENDP			; bDataCompare
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\aapo\desktop\fortnite_shait\kernel rpm\dummy\main.cpp
;	COMDAT ?FindPattern@@YA_K_K0PEAEPEAD@Z
_TEXT	SEGMENT
dwAddress$ = 8
dwLen$ = 16
bMask$dead$ = 24
szMask$dead$ = 32
?FindPattern@@YA_K_K0PEAEPEAD@Z PROC			; FindPattern, COMDAT

; 259  : {

$LN30:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 7c 24 10	 mov	 QWORD PTR [rsp+16], rdi

; 260  : 	for (UINT64 i = 0; i < dwLen; i++)

  0000a	45 33 c0	 xor	 r8d, r8d
  0000d	4c 8b d2	 mov	 r10, rdx
  00010	48 8b d9	 mov	 rbx, rcx
  00013	48 85 d2	 test	 rdx, rdx
  00016	74 5b		 je	 SHORT $LN3@FindPatter
  00018	48 8d 3d 00 00
	00 00		 lea	 rdi, OFFSET FLAT:??_C@_0P@EFCCFGKI@xx?$DP?$DP?$DP?$DP?$DPxxxxx?$DPx@FNODOBFM@
  0001f	4c 8b d9	 mov	 r11, rcx
  00022	4c 2b df	 sub	 r11, rdi
  00025	66 66 66 0f 1f
	84 00 00 00 00
	00		 npad	 11
$LL4@FindPatter:

; 261  : 		if (bDataCompare((BYTE*)(dwAddress + i), bMask, szMask))

  00030	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0P@JIBKLKFL@L?$IL?$AA?$AA?$AA?$AA?$AAL?$IL?IM?$IF?$AAt@FNODOBFM@
  00037	b1 78		 mov	 cl, 120			; 00000078H
  00039	48 8b c7	 mov	 rax, rdi
  0003c	4f 8d 0c 03	 lea	 r9, QWORD PTR [r11+r8]
$LL10@FindPatter:

; 252  : 		if (*szMask == 'x' && *pData != *bMask)

  00040	80 f9 78	 cmp	 cl, 120			; 00000078H
  00043	75 09		 jne	 SHORT $LN8@FindPatter
  00045	0f b6 0a	 movzx	 ecx, BYTE PTR [rdx]
  00048	41 38 0c 01	 cmp	 BYTE PTR [r9+rax], cl
  0004c	75 1d		 jne	 SHORT $LN15@FindPatter
$LN8@FindPatter:

; 251  : 	for (; *szMask; ++szMask, ++pData, ++bMask)

  0004e	0f b6 48 01	 movzx	 ecx, BYTE PTR [rax+1]
  00052	48 ff c0	 inc	 rax
  00055	48 ff c2	 inc	 rdx
  00058	84 c9		 test	 cl, cl
  0005a	75 e4		 jne	 SHORT $LL10@FindPatter

; 262  : 			return (UINT64)(dwAddress + i);

  0005c	49 8d 04 18	 lea	 rax, QWORD PTR [r8+rbx]

; 263  : 
; 264  : 	return 0;
; 265  : }

  00060	48 8b 5c 24 08	 mov	 rbx, QWORD PTR [rsp+8]
  00065	48 8b 7c 24 10	 mov	 rdi, QWORD PTR [rsp+16]
  0006a	c3		 ret	 0
$LN15@FindPatter:

; 260  : 	for (UINT64 i = 0; i < dwLen; i++)

  0006b	49 ff c0	 inc	 r8
  0006e	4d 3b c2	 cmp	 r8, r10
  00071	72 bd		 jb	 SHORT $LL4@FindPatter
$LN3@FindPatter:

; 263  : 
; 264  : 	return 0;
; 265  : }

  00073	48 8b 5c 24 08	 mov	 rbx, QWORD PTR [rsp+8]
  00078	33 c0		 xor	 eax, eax
  0007a	48 8b 7c 24 10	 mov	 rdi, QWORD PTR [rsp+16]
  0007f	c3		 ret	 0
?FindPattern@@YA_K_K0PEAEPEAD@Z ENDP			; FindPattern
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\aapo\desktop\fortnite_shait\kernel rpm\dummy\main.cpp
;	COMDAT ?CleanUnloadedDrivers@@YAEXZ
_TEXT	SEGMENT
bytes$ = 80
?CleanUnloadedDrivers@@YAEXZ PROC			; CleanUnloadedDrivers, COMDAT

; 268  : {

$LN50:
  00000	48 89 5c 24 18	 mov	 QWORD PTR [rsp+24], rbx
  00005	56		 push	 rsi
  00006	57		 push	 rdi
  00007	41 54		 push	 r12
  00009	41 56		 push	 r14
  0000b	41 57		 push	 r15
  0000d	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 269  : 	ULONG bytes = 0;

  00011	33 ff		 xor	 edi, edi

; 270  : 	NTSTATUS status = ZwQuerySystemInformation(SystemModuleInformation, 0, bytes, &bytes);

  00013	4c 8d 4c 24 50	 lea	 r9, QWORD PTR bytes$[rsp]
  00018	45 33 c0	 xor	 r8d, r8d
  0001b	89 7c 24 50	 mov	 DWORD PTR bytes$[rsp], edi
  0001f	33 d2		 xor	 edx, edx
  00021	8d 4f 0b	 lea	 ecx, QWORD PTR [rdi+11]
  00024	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ZwQuerySystemInformation

; 271  : 
; 272  : 	if (!bytes)

  0002a	8b 44 24 50	 mov	 eax, DWORD PTR bytes$[rsp]
  0002e	85 c0		 test	 eax, eax
  00030	0f 84 59 01 00
	00		 je	 $LN44@CleanUnloa

; 273  : 	{
; 274  : 		return FALSE;
; 275  : 	}
; 276  : 
; 277  : 	PRTL_PROCESS_MODULES modules = (PRTL_PROCESS_MODULES)ExAllocatePoolWithTag(NonPagedPool, bytes, 'esa1');

  00036	8b d0		 mov	 edx, eax
  00038	33 c9		 xor	 ecx, ecx
  0003a	41 b8 31 61 73
	65		 mov	 r8d, 1702060337		; 65736131H
  00040	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ExAllocatePoolWithTag

; 278  : 
; 279  : 	status = ZwQuerySystemInformation(SystemModuleInformation, modules, bytes, &bytes);

  00046	44 8b 44 24 50	 mov	 r8d, DWORD PTR bytes$[rsp]
  0004b	4c 8d 4c 24 50	 lea	 r9, QWORD PTR bytes$[rsp]
  00050	48 8b d0	 mov	 rdx, rax
  00053	8d 4f 0b	 lea	 ecx, QWORD PTR [rdi+11]
  00056	4c 8b f0	 mov	 r14, rax
  00059	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ZwQuerySystemInformation

; 280  : 
; 281  : 	if (!NT_SUCCESS(status))

  0005f	85 c0		 test	 eax, eax
  00061	0f 88 28 01 00
	00		 js	 $LN44@CleanUnloa

; 282  : 	{
; 283  : 		return FALSE;
; 284  : 	}
; 285  : 
; 286  : 	PRTL_PROCESS_MODULE_INFORMATION module = modules->Modules;
; 287  : 	UINT64 ntoskrnlBase = 0, ntoskrnlSize = 0;
; 288  : 
; 289  : 	for (ULONG i = 0; i < modules->NumberOfModules; i++)

  00067	41 8b 36	 mov	 esi, DWORD PTR [r14]
  0006a	44 8b e7	 mov	 r12d, edi
  0006d	44 8b ff	 mov	 r15d, edi
  00070	8b df		 mov	 ebx, edi
  00072	85 f6		 test	 esi, esi
  00074	74 48		 je	 SHORT $LN3@CleanUnloa
  00076	48 89 6c 24 58	 mov	 QWORD PTR [rsp+88], rbp
  0007b	0f 1f 44 00 00	 npad	 5
$LL4@CleanUnloa:

; 290  : 	{
; 291  : 		if (!strcmp((char*)module[i].FullPathName, "\\SystemRoot\\system32\\ntoskrnl.exe"))

  00080	8b eb		 mov	 ebp, ebx
  00082	49 8d 4e 30	 lea	 rcx, QWORD PTR [r14+48]
  00086	48 69 c5 28 01
	00 00		 imul	 rax, rbp, 296		; 00000128H
  0008d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CC@DEJEICHL@?2SystemRoot?2system32?2ntoskrnl?4e@FNODOBFM@
  00094	48 03 c8	 add	 rcx, rax
  00097	e8 00 00 00 00	 call	 strcmp
  0009c	85 c0		 test	 eax, eax
  0009e	74 08		 je	 SHORT $LN28@CleanUnloa

; 282  : 	{
; 283  : 		return FALSE;
; 284  : 	}
; 285  : 
; 286  : 	PRTL_PROCESS_MODULE_INFORMATION module = modules->Modules;
; 287  : 	UINT64 ntoskrnlBase = 0, ntoskrnlSize = 0;
; 288  : 
; 289  : 	for (ULONG i = 0; i < modules->NumberOfModules; i++)

  000a0	ff c3		 inc	 ebx
  000a2	3b de		 cmp	 ebx, esi
  000a4	72 da		 jb	 SHORT $LL4@CleanUnloa

; 261  : 		if (bDataCompare((BYTE*)(dwAddress + i), bMask, szMask))

  000a6	eb 11		 jmp	 SHORT $LN48@CleanUnloa
$LN28@CleanUnloa:

; 292  : 		{
; 293  : 			ntoskrnlBase = (UINT64)module[i].ImageBase;

  000a8	48 69 c5 28 01
	00 00		 imul	 rax, rbp, 296		; 00000128H
  000af	4e 8b 64 30 18	 mov	 r12, QWORD PTR [rax+r14+24]

; 294  : 			ntoskrnlSize = (UINT64)module[i].ImageSize;

  000b4	46 8b 7c 30 20	 mov	 r15d, DWORD PTR [rax+r14+32]
$LN48@CleanUnloa:
  000b9	48 8b 6c 24 58	 mov	 rbp, QWORD PTR [rsp+88]
$LN3@CleanUnloa:

; 295  : 			break;
; 296  : 		}
; 297  : 	}
; 298  : 
; 299  : 	if (modules)
; 300  : 		ExFreePoolWithTag(modules, 0);

  000be	33 d2		 xor	 edx, edx
  000c0	49 8b ce	 mov	 rcx, r14
  000c3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ExFreePoolWithTag

; 301  : 
; 302  : 	if (ntoskrnlBase <= 0)

  000c9	4d 85 e4	 test	 r12, r12
  000cc	0f 84 bd 00 00
	00		 je	 $LN44@CleanUnloa

; 260  : 	for (UINT64 i = 0; i < dwLen; i++)

  000d2	4d 85 ff	 test	 r15, r15
  000d5	0f 84 b4 00 00
	00		 je	 $LN44@CleanUnloa
  000db	4c 8d 15 00 00
	00 00		 lea	 r10, OFFSET FLAT:??_C@_0P@EFCCFGKI@xx?$DP?$DP?$DP?$DP?$DPxxxxx?$DPx@FNODOBFM@
  000e2	4d 8b cc	 mov	 r9, r12
  000e5	4d 2b ca	 sub	 r9, r10
  000e8	0f 1f 84 00 00
	00 00 00	 npad	 8
$LL16@CleanUnloa:

; 261  : 		if (bDataCompare((BYTE*)(dwAddress + i), bMask, szMask))

  000f0	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0P@JIBKLKFL@L?$IL?$AA?$AA?$AA?$AA?$AAL?$IL?IM?$IF?$AAt@FNODOBFM@
  000f7	b1 78		 mov	 cl, 120			; 00000078H
  000f9	49 8b c2	 mov	 rax, r10
  000fc	4d 8d 04 39	 lea	 r8, QWORD PTR [r9+rdi]
$LL22@CleanUnloa:

; 252  : 		if (*szMask == 'x' && *pData != *bMask)

  00100	80 f9 78	 cmp	 cl, 120			; 00000078H
  00103	75 09		 jne	 SHORT $LN20@CleanUnloa
  00105	0f b6 0a	 movzx	 ecx, BYTE PTR [rdx]
  00108	41 38 0c 00	 cmp	 BYTE PTR [r8+rax], cl
  0010c	75 75		 jne	 SHORT $LN29@CleanUnloa
$LN20@CleanUnloa:

; 251  : 	for (; *szMask; ++szMask, ++pData, ++bMask)

  0010e	0f b6 48 01	 movzx	 ecx, BYTE PTR [rax+1]
  00112	48 ff c0	 inc	 rax
  00115	48 ff c2	 inc	 rdx
  00118	84 c9		 test	 cl, cl
  0011a	75 e4		 jne	 SHORT $LL22@CleanUnloa

; 262  : 			return (UINT64)(dwAddress + i);

  0011c	4a 8d 0c 27	 lea	 rcx, QWORD PTR [rdi+r12]

; 303  : 	{
; 304  : 		return FALSE;
; 305  : 	}
; 306  : 
; 307  : 	// NOTE: 4C 8B ? ? ? ? ? 4C 8B C9 4D 85 ? 74 + 3] + current signature address = MmUnloadedDrivers
; 308  : 	UINT64 mmUnloadedDriversPtr = FindPattern((UINT64)ntoskrnlBase, (UINT64)ntoskrnlSize, (BYTE*)"\x4C\x8B\x00\x00\x00\x00\x00\x4C\x8B\xC9\x4D\x85\x00\x74", "xx?????xxxxx?x");
; 309  : 
; 310  : 	if (!mmUnloadedDriversPtr)

  00120	48 85 c9	 test	 rcx, rcx
  00123	74 6a		 je	 SHORT $LN44@CleanUnloa

; 311  : 	{
; 312  : 		return FALSE;
; 313  : 	}
; 314  : 
; 315  : 	UINT64 mmUnloadedDrivers = (UINT64)((PUCHAR)mmUnloadedDriversPtr + *(PULONG)((PUCHAR)mmUnloadedDriversPtr + 3) + 7);

  00125	8b 79 03	 mov	 edi, DWORD PTR [rcx+3]

; 316  : 	UINT64 bufferPtr = *(UINT64*)mmUnloadedDrivers;
; 317  : 
; 318  : 	// NOTE: 0x7D0 is the size of the MmUnloadedDrivers array for win 7 and above
; 319  : 	PVOID newBuffer = ExAllocatePoolWithTag(NonPagedPoolNx, 0x7D0, 'eas2');

  00128	ba d0 07 00 00	 mov	 edx, 2000		; 000007d0H
  0012d	48 03 f9	 add	 rdi, rcx
  00130	41 b8 32 73 61
	65		 mov	 r8d, 1700885298		; 65617332H
  00136	b9 00 02 00 00	 mov	 ecx, 512		; 00000200H
  0013b	48 8b 77 07	 mov	 rsi, QWORD PTR [rdi+7]
  0013f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ExAllocatePoolWithTag
  00145	48 8b d8	 mov	 rbx, rax

; 320  : 
; 321  : 	if (!newBuffer)

  00148	48 85 c0	 test	 rax, rax
  0014b	74 42		 je	 SHORT $LN44@CleanUnloa

; 322  : 		return FALSE;
; 323  : 
; 324  : 	memset(newBuffer, 0, 0x7D0);

  0014d	33 d2		 xor	 edx, edx
  0014f	41 b8 d0 07 00
	00		 mov	 r8d, 2000		; 000007d0H
  00155	48 8b c8	 mov	 rcx, rax
  00158	e8 00 00 00 00	 call	 memset

; 325  : 
; 326  : 	// NOTE: replace MmUnloadedDrivers
; 327  : 	*(UINT64*)mmUnloadedDrivers = (UINT64)newBuffer;
; 328  : 
; 329  : 	// NOTE: clean the old buffer
; 330  : 	ExFreePoolWithTag((PVOID)bufferPtr, 'eas2');

  0015d	ba 32 73 61 65	 mov	 edx, 1700885298		; 65617332H
  00162	48 89 5f 07	 mov	 QWORD PTR [rdi+7], rbx
  00166	48 8b ce	 mov	 rcx, rsi
  00169	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ExFreePoolWithTag

; 331  : 
; 332  : 	return TRUE;

  0016f	b0 01		 mov	 al, 1

; 333  : }

  00171	48 8b 5c 24 60	 mov	 rbx, QWORD PTR [rsp+96]
  00176	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0017a	41 5f		 pop	 r15
  0017c	41 5e		 pop	 r14
  0017e	41 5c		 pop	 r12
  00180	5f		 pop	 rdi
  00181	5e		 pop	 rsi
  00182	c3		 ret	 0
$LN29@CleanUnloa:

; 260  : 	for (UINT64 i = 0; i < dwLen; i++)

  00183	48 ff c7	 inc	 rdi
  00186	49 3b ff	 cmp	 rdi, r15
  00189	0f 82 61 ff ff
	ff		 jb	 $LL16@CleanUnloa
$LN44@CleanUnloa:

; 333  : }

  0018f	48 8b 5c 24 60	 mov	 rbx, QWORD PTR [rsp+96]
  00194	32 c0		 xor	 al, al
  00196	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0019a	41 5f		 pop	 r15
  0019c	41 5e		 pop	 r14
  0019e	41 5c		 pop	 r12
  001a0	5f		 pop	 rdi
  001a1	5e		 pop	 rsi
  001a2	c3		 ret	 0
?CleanUnloadedDrivers@@YAEXZ ENDP			; CleanUnloadedDrivers
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\aapo\desktop\fortnite_shait\kernel rpm\dummy\main.cpp
;	COMDAT ?clean_piddb_cache@@YAXXZ
_TEXT	SEGMENT
$T4 = 32
$T3 = 32
bytes$ = 112
ntoskrnlBase$1$ = 120
?clean_piddb_cache@@YAXXZ PROC				; clean_piddb_cache, COMDAT

; 335  : void clean_piddb_cache() {

$LN60:
  00000	48 89 5c 24 18	 mov	 QWORD PTR [rsp+24], rbx
  00005	55		 push	 rbp
  00006	56		 push	 rsi
  00007	57		 push	 rdi
  00008	41 54		 push	 r12
  0000a	41 55		 push	 r13
  0000c	41 56		 push	 r14
  0000e	41 57		 push	 r15
  00010	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 336  : 	ULONG bytes = 0;
; 337  : 	NTSTATUS status = ZwQuerySystemInformation(SystemModuleInformation, 0, bytes, &bytes);

  00014	33 d2		 xor	 edx, edx
  00016	4c 8d 4c 24 70	 lea	 r9, QWORD PTR bytes$[rsp]
  0001b	45 33 e4	 xor	 r12d, r12d
  0001e	45 33 c0	 xor	 r8d, r8d
  00021	44 89 64 24 70	 mov	 DWORD PTR bytes$[rsp], r12d
  00026	8d 4a 0b	 lea	 ecx, QWORD PTR [rdx+11]
  00029	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ZwQuerySystemInformation

; 338  : 
; 339  : 	PRTL_PROCESS_MODULES modules = (PRTL_PROCESS_MODULES)ExAllocatePoolWithTag(NonPagedPool, bytes, 'no43'); // 'ENON'

  0002f	8b 54 24 70	 mov	 edx, DWORD PTR bytes$[rsp]
  00033	33 c9		 xor	 ecx, ecx
  00035	41 b8 33 34 6f
	6e		 mov	 r8d, 1852781619		; 6e6f3433H
  0003b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ExAllocatePoolWithTag

; 340  : 
; 341  : 	status = ZwQuerySystemInformation(SystemModuleInformation, modules, bytes, &bytes);

  00041	44 8b 44 24 70	 mov	 r8d, DWORD PTR bytes$[rsp]
  00046	4c 8d 4c 24 70	 lea	 r9, QWORD PTR bytes$[rsp]
  0004b	48 8b d0	 mov	 rdx, rax
  0004e	41 8d 4c 24 0b	 lea	 ecx, QWORD PTR [r12+11]
  00053	4c 8b f0	 mov	 r14, rax
  00056	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ZwQuerySystemInformation

; 342  : 
; 343  : 	PRTL_PROCESS_MODULE_INFORMATION module = modules->Modules;
; 344  : 	UINT64 ntoskrnlBase = 0, ntoskrnlSize = 0;
; 345  : 
; 346  : 	for (ULONG i = 0; i < modules->NumberOfModules; i++)

  0005c	41 8b 36	 mov	 esi, DWORD PTR [r14]
  0005f	41 8b ec	 mov	 ebp, r12d
  00062	4c 89 64 24 78	 mov	 QWORD PTR ntoskrnlBase$1$[rsp], r12
  00067	45 8b ec	 mov	 r13d, r12d
  0006a	41 8b dc	 mov	 ebx, r12d
  0006d	85 f6		 test	 esi, esi
  0006f	74 3e		 je	 SHORT $LN3@clean_pidd
$LL4@clean_pidd:

; 347  : 	{
; 348  : 		if (!strcmp((char*)module[i].FullPathName, "\\SystemRoot\\system32\\ntoskrnl.exe"))

  00071	8b fb		 mov	 edi, ebx
  00073	49 8d 4e 30	 lea	 rcx, QWORD PTR [r14+48]
  00077	48 69 c7 28 01
	00 00		 imul	 rax, rdi, 296		; 00000128H
  0007e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CC@DEJEICHL@?2SystemRoot?2system32?2ntoskrnl?4e@FNODOBFM@
  00085	48 03 c8	 add	 rcx, rax
  00088	e8 00 00 00 00	 call	 strcmp
  0008d	85 c0		 test	 eax, eax
  0008f	74 08		 je	 SHORT $LN35@clean_pidd

; 342  : 
; 343  : 	PRTL_PROCESS_MODULE_INFORMATION module = modules->Modules;
; 344  : 	UINT64 ntoskrnlBase = 0, ntoskrnlSize = 0;
; 345  : 
; 346  : 	for (ULONG i = 0; i < modules->NumberOfModules; i++)

  00091	ff c3		 inc	 ebx
  00093	3b de		 cmp	 ebx, esi
  00095	72 da		 jb	 SHORT $LL4@clean_pidd

; 233  : 		if (accumulative_found)

  00097	eb 16		 jmp	 SHORT $LN3@clean_pidd
$LN35@clean_pidd:

; 349  : 		{
; 350  : 			ntoskrnlBase = (UINT64)module[i].ImageBase;

  00099	48 69 c7 28 01
	00 00		 imul	 rax, rdi, 296		; 00000128H
  000a0	4a 8b 6c 30 18	 mov	 rbp, QWORD PTR [rax+r14+24]

; 351  : 			ntoskrnlSize = (UINT64)module[i].ImageSize;

  000a5	46 8b 6c 30 20	 mov	 r13d, DWORD PTR [rax+r14+32]
  000aa	48 89 6c 24 78	 mov	 QWORD PTR ntoskrnlBase$1$[rsp], rbp
$LN3@clean_pidd:

; 352  : 			break;
; 353  : 		}
; 354  : 	}
; 355  : 
; 356  : 	if (modules)
; 357  : 		ExFreePoolWithTag(modules, 0);

  000af	33 d2		 xor	 edx, edx
  000b1	49 8b ce	 mov	 rcx, r14
  000b4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ExFreePoolWithTag

; 212  : 	const auto pattern_length = strlen(mask);

  000ba	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BC@GGMFPPBL@xxx?$DP?$DP?$DP?$DPxxx?$DP?$DP?$DP?$DPxxx@FNODOBFM@
  000c1	48 c7 c7 ff ff
	ff ff		 mov	 rdi, -1
  000c8	0f 1f 84 00 00
	00 00 00	 npad	 8
$LL57@clean_pidd:
  000d0	48 ff c7	 inc	 rdi
  000d3	44 38 24 38	 cmp	 BYTE PTR [rax+rdi], r12b
  000d7	75 f7		 jne	 SHORT $LL57@clean_pidd

; 213  : 
; 214  : 	for (size_t i = 0; i <= length - pattern_length; i++)

  000d9	4c 2b ef	 sub	 r13, rdi

; 352  : 			break;
; 353  : 		}
; 354  : 	}
; 355  : 
; 356  : 	if (modules)
; 357  : 		ExFreePoolWithTag(modules, 0);

  000dc	4c 8b fd	 mov	 r15, rbp
  000df	49 f7 df	 neg	 r15
  000e2	48 8b f5	 mov	 rsi, rbp
$LN58@clean_pidd:

; 218  : 		for (size_t j = 0; j < pattern_length; j++)

  000e5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BC@LCGEEDHA@H?$IN?$AN?$AA?$AA?$AA?$AAL?$IJ5?$AA?$AA?$AA?$AAI?$IL?i@FNODOBFM@
  000ec	48 85 ff	 test	 rdi, rdi
  000ef	74 41		 je	 SHORT $LN38@clean_pidd
  000f1	48 8b de	 mov	 rbx, rsi
  000f4	4d 8d 34 0f	 lea	 r14, QWORD PTR [r15+rcx]
  000f8	49 8d 2c 07	 lea	 rbp, QWORD PTR [r15+rax]
  000fc	0f 1f 40 00	 npad	 4
$LL23@clean_pidd:

; 219  : 		{
; 220  : 			if (!MmIsAddressValid(reinterpret_cast<void*>(reinterpret_cast<uintptr_t>(data) + i + j)))

  00100	48 8b cb	 mov	 rcx, rbx
  00103	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_MmIsAddressValid
  00109	84 c0		 test	 al, al
  0010b	0f 84 c8 00 00
	00		 je	 $LN37@clean_pidd

; 221  : 			{
; 222  : 				accumulative_found = false;
; 223  : 				break;
; 224  : 			}
; 225  : 
; 226  : 			if (data[i + j] != pattern[j] && mask[j] != '?')

  00111	41 0f b6 04 1e	 movzx	 eax, BYTE PTR [r14+rbx]
  00116	38 03		 cmp	 BYTE PTR [rbx], al
  00118	74 0a		 je	 SHORT $LN21@clean_pidd
  0011a	80 3c 2b 3f	 cmp	 BYTE PTR [rbx+rbp], 63	; 0000003fH
  0011e	0f 85 b5 00 00
	00		 jne	 $LN37@clean_pidd
$LN21@clean_pidd:

; 215  : 	{
; 216  : 		bool accumulative_found = true;
; 217  : 
; 218  : 		for (size_t j = 0; j < pattern_length; j++)

  00124	48 ff c3	 inc	 rbx
  00127	48 8b c3	 mov	 rax, rbx
  0012a	48 2b c6	 sub	 rax, rsi
  0012d	48 3b c7	 cmp	 rax, rdi
  00130	72 ce		 jb	 SHORT $LL23@clean_pidd
$LN38@clean_pidd:

; 234  : 		{
; 235  : 			return (t)(reinterpret_cast<uintptr_t>(data) + i);

  00132	48 8b 4c 24 78	 mov	 rcx, QWORD PTR ntoskrnlBase$1$[rsp]
  00137	49 03 cc	 add	 rcx, r12

; 243  : 	if (address == 0)

  0013a	0f 84 b3 00 00
	00		 je	 $LN55@clean_pidd

; 244  : 		return 0;
; 245  : 
; 246  : 	return address + (int)((*(int*)(address + offset) + offset) + sizeof(int));

  00140	48 63 41 03	 movsxd	 rax, DWORD PTR [rcx+3]
  00144	4c 8d 41 07	 lea	 r8, QWORD PTR [rcx+7]
  00148	4c 03 c0	 add	 r8, rax

; 358  : 
; 359  : 	PRTL_AVL_TABLE PiDDBCacheTable;
; 360  : 	PiDDBCacheTable = (PRTL_AVL_TABLE)dereference(find_pattern<uintptr_t>((void*)ntoskrnlBase, ntoskrnlSize, "\x48\x8D\x0D\x00\x00\x00\x00\x4C\x89\x35\x00\x00\x00\x00\x49\x8B\xE9", "xxx????xxx????xxx"), 3); //windows 10 sig \x48\x8D\x0D\x00\x00\x00\x00\x4C\x89\x35\x00\x00\x00\x00\x49\x8B\xE9 xxx????xxx????xxx       windows 7-8.1 sig \x48\x8d\x0d\x00\x00\x00\x00\xe8\x00\x00\x00\x00\x48\x85\xc0\x74\x00\x48\x8b\x0d xxx????x????xxxx?xxx
; 361  : 	
; 362  : 	if (!PiDDBCacheTable)

  0014b	0f 84 a2 00 00
	00		 je	 $LN55@clean_pidd

; 365  : 	}
; 366  : 	else
; 367  : 	{
; 368  : 		uintptr_t entry_address = uintptr_t(PiDDBCacheTable->BalancedRoot.RightChild) + sizeof(RTL_BALANCED_LINKS);

  00151	4d 8b 40 10	 mov	 r8, QWORD PTR [r8+16]

; 369  : 
; 370  : 		piddbcache* entry = (piddbcache*)(entry_address);
; 371  : 
; 372  : 		/*capcom.sys(drvmap) : 0x57CD1415 iqvw64e.sys(kdmapper) : 0x5284EAC3*/
; 373  : 		if (entry->TimeDateStamp == 0x57CD1415 || entry->TimeDateStamp == 0x5284EAC3) {

  00155	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:??_C@_1BE@MNFNHFL@?$AA3?$AA2?$AA4?$AA6?$AA1?$AA?4?$AAs?$AAy?$AAs@FNODOBFM@
  0015c	b9 c7 ea 70 00	 mov	 ecx, 7400135		; 0070eac7H
  00161	41 8b 40 40	 mov	 eax, DWORD PTR [r8+64]
  00165	3d 15 14 cd 57	 cmp	 eax, 1473057813		; 57cd1415H
  0016a	74 07		 je	 SHORT $LN13@clean_pidd
  0016c	3d c3 ea 84 52	 cmp	 eax, 1384442563		; 5284eac3H
  00171	75 1b		 jne	 SHORT $LN12@clean_pidd
$LN13@clean_pidd:

; 374  : 
; 375  : 			entry->TimeDateStamp = 0x70EAC7; //change timestamp
; 376  : 			entry->DriverName = RTL_CONSTANT_STRING(L"32461.sys"); //change driver name

  00173	c7 44 24 20 12
	00 14 00	 mov	 DWORD PTR $T3[rsp], 1310738 ; 00140012H
  0017b	4c 89 4c 24 28	 mov	 QWORD PTR $T3[rsp+8], r9
  00180	0f 10 44 24 20	 movups	 xmm0, XMMWORD PTR $T3[rsp]
  00185	41 89 48 40	 mov	 DWORD PTR [r8+64], ecx
  00189	41 0f 11 40 30	 movups	 XMMWORD PTR [r8+48], xmm0
$LN12@clean_pidd:

; 377  : 		}
; 378  : 
; 379  : 		ULONG count = 0;
; 380  : 
; 381  : 		for (auto link = entry->List.Flink; link != entry->List.Blink; link = link->Flink, count++)

  0018e	49 8b 40 20	 mov	 rax, QWORD PTR [r8+32]
  00192	49 3b 40 28	 cmp	 rax, QWORD PTR [r8+40]
  00196	74 68		 je	 SHORT $LN6@clean_pidd
  00198	0f 1f 84 00 00
	00 00 00	 npad	 8
$LL7@clean_pidd:

; 382  : 		{
; 383  : 			piddbcache* cache_entry = (piddbcache*)(link);
; 384  : 
; 385  : 			if (cache_entry->TimeDateStamp == 0x57CD1415 || cache_entry->TimeDateStamp == 0x5284EAC3) {

  001a0	8b 50 20	 mov	 edx, DWORD PTR [rax+32]
  001a3	81 fa 15 14 cd
	57		 cmp	 edx, 1473057813		; 57cd1415H
  001a9	74 08		 je	 SHORT $LN15@clean_pidd
  001ab	81 fa c3 ea 84
	52		 cmp	 edx, 1384442563		; 5284eac3H
  001b1	75 19		 jne	 SHORT $LN5@clean_pidd
$LN15@clean_pidd:

; 386  : 
; 387  : 				cache_entry->TimeDateStamp = 0x70EAC7 + count;
; 388  : 				cache_entry->DriverName = RTL_CONSTANT_STRING(L"32461.sys");

  001b3	c7 44 24 20 12
	00 14 00	 mov	 DWORD PTR $T4[rsp], 1310738 ; 00140012H
  001bb	4c 89 4c 24 28	 mov	 QWORD PTR $T4[rsp+8], r9
  001c0	0f 10 44 24 20	 movups	 xmm0, XMMWORD PTR $T4[rsp]
  001c5	89 48 20	 mov	 DWORD PTR [rax+32], ecx
  001c8	0f 11 40 10	 movups	 XMMWORD PTR [rax+16], xmm0
$LN5@clean_pidd:

; 377  : 		}
; 378  : 
; 379  : 		ULONG count = 0;
; 380  : 
; 381  : 		for (auto link = entry->List.Flink; link != entry->List.Blink; link = link->Flink, count++)

  001cc	48 8b 00	 mov	 rax, QWORD PTR [rax]
  001cf	ff c1		 inc	 ecx
  001d1	49 3b 40 28	 cmp	 rax, QWORD PTR [r8+40]
  001d5	75 c9		 jne	 SHORT $LL7@clean_pidd
  001d7	eb 27		 jmp	 SHORT $LN6@clean_pidd
$LN37@clean_pidd:

; 214  : 	for (size_t i = 0; i <= length - pattern_length; i++)

  001d9	49 ff c4	 inc	 r12
  001dc	49 ff cf	 dec	 r15
  001df	48 ff c6	 inc	 rsi
  001e2	4d 3b e5	 cmp	 r12, r13
  001e5	77 0c		 ja	 SHORT $LN55@clean_pidd
  001e7	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BC@GGMFPPBL@xxx?$DP?$DP?$DP?$DPxxx?$DP?$DP?$DP?$DPxxx@FNODOBFM@
  001ee	e9 f2 fe ff ff	 jmp	 $LN58@clean_pidd
$LN55@clean_pidd:

; 363  : 	{
; 364  : 		DbgPrint("Failed to find PiddbCachetable!");

  001f3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CA@MAGIKHML@Failed?5to?5find?5PiddbCachetable?$CB@FNODOBFM@
  001fa	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_DbgPrint
$LN6@clean_pidd:

; 389  : 			}
; 390  : 			//DbgPrint("cache_entry count: %lu name: %wZ \t\t stamp: %x\n", count, cache_entry->DriverName, cache_entry->TimeDateStamp);
; 391  : 		}
; 392  : 	}
; 393  : }

  00200	48 8b 9c 24 80
	00 00 00	 mov	 rbx, QWORD PTR [rsp+128]
  00208	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0020c	41 5f		 pop	 r15
  0020e	41 5e		 pop	 r14
  00210	41 5d		 pop	 r13
  00212	41 5c		 pop	 r12
  00214	5f		 pop	 rdi
  00215	5e		 pop	 rsi
  00216	5d		 pop	 rbp
  00217	c3		 ret	 0
?clean_piddb_cache@@YAXXZ ENDP				; clean_piddb_cache
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\aapo\desktop\fortnite_shait\kernel rpm\dummy\main.cpp
;	COMDAT DriverEntry
_TEXT	SEGMENT
driver_object$ = 80
registry_path$ = 88
thread_handle$ = 96
DriverEntry PROC					; COMDAT

; 399  : {

$LN5:
  00000	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 400  : 	// These are invalid for mapped drivers.
; 401  : 	UNREFERENCED_PARAMETER(driver_object);
; 402  : 	UNREFERENCED_PARAMETER(registry_path);
; 403  : 
; 404  : 	clean_piddb_cache();

  00004	e8 00 00 00 00	 call	 ?clean_piddb_cache@@YAXXZ ; clean_piddb_cache

; 405  : 	CleanUnloadedDrivers();

  00009	e8 00 00 00 00	 call	 ?CleanUnloadedDrivers@@YAEXZ ; CleanUnloadedDrivers

; 406  : 
; 407  : 	HANDLE thread_handle = nullptr;

  0000e	33 c9		 xor	 ecx, ecx

; 408  : 
; 409  : 	// Create server thread that will wait for incoming connections.
; 410  : 	const auto status = PsCreateSystemThread(

  00010	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:?server_thread@@YAXPEAX@Z ; server_thread
  00017	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0001c	45 33 c9	 xor	 r9d, r9d
  0001f	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00024	45 33 c0	 xor	 r8d, r8d
  00027	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  0002c	ba 00 00 00 10	 mov	 edx, 268435456		; 10000000H
  00031	48 89 4c 24 60	 mov	 QWORD PTR thread_handle$[rsp], rcx
  00036	48 8d 4c 24 60	 lea	 rcx, QWORD PTR thread_handle$[rsp]
  0003b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_PsCreateSystemThread

; 411  : 		&thread_handle,
; 412  : 		GENERIC_ALL,
; 413  : 		nullptr,
; 414  : 		nullptr,
; 415  : 		nullptr,
; 416  : 		server_thread,
; 417  : 		nullptr
; 418  : 	);
; 419  : 
; 420  : 	if (!NT_SUCCESS(status))

  00041	85 c0		 test	 eax, eax
  00043	79 0a		 jns	 SHORT $LN2@DriverEntr

; 421  : 	{
; 422  : 		//log("Failed to create server thread. Status code: %X.", status);
; 423  : 		return STATUS_UNSUCCESSFUL;

  00045	b8 01 00 00 c0	 mov	 eax, -1073741823	; ffffffffc0000001H

; 429  : }

  0004a	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0004e	c3		 ret	 0
$LN2@DriverEntr:

; 424  : 	}
; 425  : 
; 426  : 	ZwClose(thread_handle);

  0004f	48 8b 4c 24 60	 mov	 rcx, QWORD PTR thread_handle$[rsp]
  00054	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ZwClose

; 427  : 
; 428  : 	return STATUS_SUCCESS;

  0005a	33 c0		 xor	 eax, eax

; 429  : }

  0005c	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00060	c3		 ret	 0
DriverEntry ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\aapo\desktop\fortnite_shait\kernel rpm\dummy\main.cpp
;	COMDAT ??$find_pattern@_K@@YA_KPEAX_KPEBD2@Z
_TEXT	SEGMENT
start$ = 80
length$ = 88
pattern$dead$ = 96
mask$dead$ = 104
??$find_pattern@_K@@YA_KPEAX_KPEBD2@Z PROC		; find_pattern<unsigned __int64>, COMDAT

; 210  : t find_pattern(void* start, size_t length, const char* pattern, const char* mask) {

$LN28:
  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	48 89 6c 24 18	 mov	 QWORD PTR [rsp+24], rbp
  0000a	48 89 74 24 20	 mov	 QWORD PTR [rsp+32], rsi
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	57		 push	 rdi
  00015	41 54		 push	 r12
  00017	41 55		 push	 r13
  00019	41 56		 push	 r14
  0001b	41 57		 push	 r15
  0001d	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00021	48 8b c1	 mov	 rax, rcx
  00024	4c 8b ea	 mov	 r13, rdx

; 211  : 	const auto data = static_cast<const char*>(start);
; 212  : 	const auto pattern_length = strlen(mask);

  00027	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BC@GGMFPPBL@xxx?$DP?$DP?$DP?$DPxxx?$DP?$DP?$DP?$DPxxx@FNODOBFM@
  0002e	48 c7 c7 ff ff
	ff ff		 mov	 rdi, -1
$LL26@find_patte:
  00035	48 ff c7	 inc	 rdi
  00038	80 3c 39 00	 cmp	 BYTE PTR [rcx+rdi], 0
  0003c	75 f7		 jne	 SHORT $LL26@find_patte
  0003e	4c 8b e0	 mov	 r12, rax

; 213  : 
; 214  : 	for (size_t i = 0; i <= length - pattern_length; i++)

  00041	45 33 ff	 xor	 r15d, r15d
  00044	4c 2b ef	 sub	 r13, rdi
  00047	48 8b f0	 mov	 rsi, rax
  0004a	49 f7 dc	 neg	 r12
  0004d	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BC@LCGEEDHA@H?$IN?$AN?$AA?$AA?$AA?$AAL?$IJ5?$AA?$AA?$AA?$AAI?$IL?i@FNODOBFM@
$LL4@find_patte:

; 215  : 	{
; 216  : 		bool accumulative_found = true;
; 217  : 
; 218  : 		for (size_t j = 0; j < pattern_length; j++)

  00054	48 85 ff	 test	 rdi, rdi
  00057	74 35		 je	 SHORT $LN16@find_patte
  00059	48 8b de	 mov	 rbx, rsi
  0005c	4d 8d 34 04	 lea	 r14, QWORD PTR [r12+rax]
  00060	49 8d 2c 0c	 lea	 rbp, QWORD PTR [r12+rcx]
$LL7@find_patte:

; 219  : 		{
; 220  : 			if (!MmIsAddressValid(reinterpret_cast<void*>(reinterpret_cast<uintptr_t>(data) + i + j)))

  00064	48 8b cb	 mov	 rcx, rbx
  00067	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_MmIsAddressValid
  0006d	84 c0		 test	 al, al
  0006f	74 42		 je	 SHORT $LN15@find_patte

; 221  : 			{
; 222  : 				accumulative_found = false;
; 223  : 				break;
; 224  : 			}
; 225  : 
; 226  : 			if (data[i + j] != pattern[j] && mask[j] != '?')

  00071	41 0f b6 04 1e	 movzx	 eax, BYTE PTR [r14+rbx]
  00076	38 03		 cmp	 BYTE PTR [rbx], al
  00078	74 06		 je	 SHORT $LN5@find_patte
  0007a	80 3c 2b 3f	 cmp	 BYTE PTR [rbx+rbp], 63	; 0000003fH
  0007e	75 33		 jne	 SHORT $LN15@find_patte
$LN5@find_patte:

; 215  : 	{
; 216  : 		bool accumulative_found = true;
; 217  : 
; 218  : 		for (size_t j = 0; j < pattern_length; j++)

  00080	48 ff c3	 inc	 rbx
  00083	48 8b c3	 mov	 rax, rbx
  00086	48 2b c6	 sub	 rax, rsi
  00089	48 3b c7	 cmp	 rax, rdi
  0008c	72 d6		 jb	 SHORT $LL7@find_patte
$LN16@find_patte:

; 227  : 			{
; 228  : 				accumulative_found = false;
; 229  : 				break;
; 230  : 			}
; 231  : 		}
; 232  : 
; 233  : 		if (accumulative_found)
; 234  : 		{
; 235  : 			return (t)(reinterpret_cast<uintptr_t>(data) + i);

  0008e	48 8b 44 24 50	 mov	 rax, QWORD PTR start$[rsp]
  00093	49 03 c7	 add	 rax, r15
$LN1@find_patte:

; 240  : }

  00096	48 8b 5c 24 58	 mov	 rbx, QWORD PTR [rsp+88]
  0009b	48 8b 6c 24 60	 mov	 rbp, QWORD PTR [rsp+96]
  000a0	48 8b 74 24 68	 mov	 rsi, QWORD PTR [rsp+104]
  000a5	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000a9	41 5f		 pop	 r15
  000ab	41 5e		 pop	 r14
  000ad	41 5d		 pop	 r13
  000af	41 5c		 pop	 r12
  000b1	5f		 pop	 rdi
  000b2	c3		 ret	 0
$LN15@find_patte:

; 213  : 
; 214  : 	for (size_t i = 0; i <= length - pattern_length; i++)

  000b3	49 ff c7	 inc	 r15
  000b6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BC@GGMFPPBL@xxx?$DP?$DP?$DP?$DPxxx?$DP?$DP?$DP?$DPxxx@FNODOBFM@
  000bd	49 ff cc	 dec	 r12
  000c0	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BC@LCGEEDHA@H?$IN?$AN?$AA?$AA?$AA?$AAL?$IJ5?$AA?$AA?$AA?$AAI?$IL?i@FNODOBFM@
  000c7	48 ff c6	 inc	 rsi
  000ca	4d 3b fd	 cmp	 r15, r13
  000cd	76 85		 jbe	 SHORT $LL4@find_patte

; 236  : 		}
; 237  : 	}
; 238  : 
; 239  : 	return (t)nullptr;

  000cf	33 c0		 xor	 eax, eax
  000d1	eb c3		 jmp	 SHORT $LN1@find_patte
??$find_pattern@_K@@YA_KPEAX_KPEBD2@Z ENDP		; find_pattern<unsigned __int64>
_TEXT	ENDS
END
